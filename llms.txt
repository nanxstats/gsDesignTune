# gsDesignTune

Enables systematic, dependency-aware scenario exploration for group
sequential designs created by gsDesign. gsDesignTune is built for
**design-space evaluation** (ranking, filtering, Pareto trade-offs)
rather than claiming a single “optimal design”. With a focus on user
experience, correctness, and speed, it supports off-the-shelf parallel
processing with progress tracking, caching, and reproducible reporting.

## Installation

You can install the development version of gsDesignTune from GitHub
with:

``` r
# install.packages("pak")
pak::pak("nanxstats/gsDesignTune")
```

## Features

- Drop-in workflow: replace
  [`gsDesign()`](https://keaven.github.io/gsDesign/reference/gsDesign.html)/[`gsSurv()`](https://keaven.github.io/gsDesign/reference/nSurv.html)/[`gsSurvCalendar()`](https://keaven.github.io/gsDesign/reference/gsSurvCalendar.html)
  with
  [`gsDesignTune()`](https://nanx.me/gsDesignTune/reference/gsDesignTune.md)/[`gsSurvTune()`](https://nanx.me/gsDesignTune/reference/gsSurvTune.md)/[`gsSurvCalendarTune()`](https://nanx.me/gsDesignTune/reference/gsSurvCalendarTune.md),
  then `$run()`.
- Dependency-aware tuning: express design parameter dependency
  relationships precisely, for example, spending functions and their
  spending parameters.
- Grid and random search over candidate sets, with vector-valued
  arguments treated atomically.
- Parallel evaluation via {future} / {future.apply} with progress via
  {progressr}. Use any {future} backend that fits your infrastructure.
- Reproducible and auditable results: per-configuration warnings/errors
  and reconstructable underlying call.
- Optional caching of design objects to disk and HTML reporting via
  {rmarkdown}.

## Quick start

Evaluate time-to-event designs:

``` r
library(gsDesign)
library(gsDesignTune)
library(future)

plan(multisession, workers = 2)

job <- gsSurvTune(
  k = 3,
  test.type = 4,
  alpha = 0.025,
  beta = 0.10,
  timing = tune_values(list(c(0.33, 0.67, 1), c(0.5, 0.75, 1))),
  hr = tune_seq(0.55, 0.75, length_out = 5),
  upper = SpendingFamily$new(
    SpendingSpec$new(sfLDOF, par = tune_fixed(0)),
    SpendingSpec$new(sfHSD, par = tune_seq(-4, 4, length_out = 9))
  ),
  lower = SpendingSpec$new(sfLDOF, par = tune_fixed(0)),
  lambdaC = log(2) / 6,
  eta = 0.01,
  gamma = c(2.5, 5, 7.5, 10),
  R = c(2, 2, 2, 6),
  T = 18,
  minfup = 6,
  ratio = 1
)

job$run(strategy = "grid", parallel = TRUE, seed = 1, cache_dir = "gstune_cache")

res <- job$results()
head(res)

job$best("final_events", direction = "min")
job$pareto(metrics = c("final_events", "upper_z1"), directions = c("min", "min"))

job$plot(metric = "final_events", x = "hr", color = "upper_fun")
```

![](reference/figures/README-example-1.svg)

``` r
job$report("gstune_report.html")
```

## Tune specifications

- `tune_fixed(x)`: explicit fixed value (useful inside dependencies)
- `tune_values(list(...))`: explicit candidates (supports vector-valued
  candidates)
- `tune_seq(from, to, length_out)`, `tune_int(from, to, by)`
- `tune_choice(...)`: categorical choices
- `tune_dep(depends_on, map)`: dependent mapping for any argument

See vignettes for end-to-end examples, spending function tuning, and
parallel + reproducible reporting.

# Package index

## Tune jobs

Create a tune job

- [`gsDesignTune()`](https://nanx.me/gsDesignTune/reference/gsDesignTune.md)
  :

  Create a tune job for
  [`gsDesign::gsDesign()`](https://keaven.github.io/gsDesign/reference/gsDesign.html)

- [`gsSurvTune()`](https://nanx.me/gsDesignTune/reference/gsSurvTune.md)
  :

  Create a tune job for
  [`gsDesign::gsSurv()`](https://keaven.github.io/gsDesign/reference/nSurv.html)

- [`gsSurvCalendarTune()`](https://nanx.me/gsDesignTune/reference/gsSurvCalendarTune.md)
  :

  Create a tune job for
  [`gsDesign::gsSurvCalendar()`](https://keaven.github.io/gsDesign/reference/gsSurvCalendar.html)

## Tune job workflow

R6 class for running searches, collecting results, and exploring designs

- [`GSDTuneJob`](https://nanx.me/gsDesignTune/reference/GSDTuneJob.md) :
  GSDTuneJob

## Spending function tuning

User-friendly specifications for spending functions and their parameters

- [`spending_specs`](https://nanx.me/gsDesignTune/reference/spending_specs.md)
  : Spending function specifications
- [`SpendingSpec`](https://nanx.me/gsDesignTune/reference/SpendingSpec.md)
  : SpendingSpec
- [`SpendingFamily`](https://nanx.me/gsDesignTune/reference/SpendingFamily.md)
  : SpendingFamily

## Tune specifications

Define candidate sets and dependencies for arguments to be explored

- [`tune_specs`](https://nanx.me/gsDesignTune/reference/tune_specs.md) :
  Tune specifications
- [`tune_fixed()`](https://nanx.me/gsDesignTune/reference/tune_fixed.md)
  : Fixed (non-tuned) value
- [`tune_values()`](https://nanx.me/gsDesignTune/reference/tune_values.md)
  : Explicit candidate values
- [`tune_seq()`](https://nanx.me/gsDesignTune/reference/tune_seq.md) :
  Numeric sequence candidates
- [`tune_int()`](https://nanx.me/gsDesignTune/reference/tune_int.md) :
  Integer sequence candidates
- [`tune_choice()`](https://nanx.me/gsDesignTune/reference/tune_choice.md)
  : Categorical choices
- [`tune_dep()`](https://nanx.me/gsDesignTune/reference/tune_dep.md) :
  Dependent tuning specification

# Articles

### Vignettes

- [Getting started with
  gsDesignTune](https://nanx.me/gsDesignTune/articles/gsDesignTune.md):
- [Spending functions and dependent
  parameters](https://nanx.me/gsDesignTune/articles/spending.md):
- [Parallel evaluation and reproducible
  reporting](https://nanx.me/gsDesignTune/articles/parallel.md):
